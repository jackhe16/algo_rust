//! # 红黑树
//!
//! ## 性质
//! - 性质1: 根节点和NULL节点都为黑
//! - 性质2: 每条路径不能出现两个连续红节点
//! - 性质3: 任一节点到NULL节点的所有路径的黑节点数量相同
//!
//! ## 算法思路
//! - 一律默认插入红节点, 插入红节点不会影响性质3
//!   - 当插入根节点时, 性质1破坏, 直接调整为黑节点
//!   - 父节点为红节点时, 性质2破坏
//!     - 叔节点为红节点时, 父叔爷节点颜色反转, 变为黑黑红, 此时爷节点为红, 视为插入节点, 重复判断叔节点
//!     - 叔节点为黑节点时(NULL也算), 分析当前(c),父(f),爷(g)节点形态
//!       - LL: g.left=f, f.left = c, 右旋g, 操作点和旋转中心点颜色反转
//!       - RR: g.right = f, f.right = c, 左旋g, 操作点和旋转中心点颜色反转
//!       - LR: g.left = f, f.right = c, 左旋f再右旋g, 右旋g的操作点和旋转中心点颜色反转
//!       - RL: g.right = f, f.left = c, 右旋f再左旋g, 左旋g的操作点和旋转中心点颜色反转
//! - 删除操作
//!   - (过程x) 当前节点没有左右孩
//!     - 当前为红, 直接删除
//!     - 当前(c)为黑
//!       - (过程a) 分析兄节点
//!         - 兄(s)节点为黑, 分析兄节点的孩节点, (删除c后?)
//!           - 兄的孩至少一个红节点, 红孩(r)节点(两个为红时,兄为父的左孩即看兄的左孩,兄为父的右孩即看兄的右孩), 分析父(p),兄(s),兄红孩(r)
//!             - LL: p.left = s, s.left = r, r变s色, s变p色, p变黑色, 右旋p
//!             - RR: p.right = s, s.right = r, r变s色, s变p色, p变黑色, 左旋p
//!             - LR: p.left = s, s.right = r, r变p色, 左旋s再右旋p
//!             - RL: p.right = s, s.left = r, r变p色, 右旋s再左旋p
//!           - 兄的孩都是黑节点
//!             - 兄变红, 当前节点转移到父节点
//!               - 当前节点(即原来的父节点)为根节点时, 直接将其变黑即可
//!               - 当前节点(即原来的 父节点)为黑时, 重复(过程a)一次
//!               - 当前节点(即原来的父节点)为红时, 直接将其变黑即可
//!          - 兄节点为红, 则兄父变色, 父朝当前(c)方向旋转, 当前节点继续, 重复(过程a)一次
//!   - (过程y) 当前节点只有左孩或右孩, 则必然当前节点为黑, 左孩或右孩为红
//!     - 删除当前, 用左孩或右孩替代当前, 将其变黑
//!   - 当前节点有左右孩
//!     - 用左孩最大或右孩最小的值替换当前节点的值, 将当前节点设为左孩最大或右孩最小, 问题变成删除该节点, 即(过程x)或(过程y)
